/* This file is processed by bison/yacc to generate cf_parser.[h/c]
   cf_parser.h is used by both the parser and lexer (generated by flex)
   Most notably the header includes strings and enums for the tokens.

   cf_parser.c is the parser logic, (the program which takes tokens from the
   lexer, validates the syntax and builds a data structure / syntax tree).

   See cf_tokenizer.l for the rules which generate the lexer (tokenizer).
*/

%define api.pure full
%param { yyscan_t scanner }
%param { Parser *parser }
%define api.value.type {char *}
%token SEMICOLON COMMA OPEN_CURLY CLOSE_CURLY FAT_ARROW BODY QUOTED_STRING IDENTIFIER UNKNOWN
%token-table

/* Added to the top of .c file: */
%code top {
#include <stdio.h>
#include <string.h>
}

/* Added to both .h and .c file (after top): */
%code requires {

#include "parse_lib.h"
typedef void* yyscan_t;

void print_token(int t, const char *string, Parser *parser);

}

/* Added to both .h and .c file (after requires): */
%code provides {
#define YY_DECL \
    int yylex(YYSTYPE* yylval_param, yyscan_t yyscanner, Parser *parser)
YY_DECL;

void yyerror(yyscan_t unused, Parser *parser, const char* msg);
}

/* Added to .c file (after top and requires): */
%code {

void yyerror(yyscan_t unused, Parser *parser, const char* msg)
{
    parser->errors += 1;
    fprintf(stderr, RED "\nSyntax error " RST "in %s:%zu\n", parser->policy->name, parser->line_number);

    if (parser->current_line != NULL)
    {
        fprintf(stderr, "\n%s\n", parser->current_line);
        size_t spaces = parser->column_number - 1;
        size_t token_length = strlen(parser->current_token);
        if (token_length > spaces)
        {
            spaces = 0;
        }
        else
        {
            spaces -= (token_length);
        }
        for (int i = 0; i < spaces; ++i)
        {
            fprintf(stderr, " ");
        }

        fprintf(stderr, RED);
        fprintf(stderr, "^ Unexpected token: %s\n\n", parser->current_token);
        fprintf(stderr, RST);
    }
}

int yywrap()
{
    return 1;
}

}

%%
policy_file:
    %empty
    | body_list
    ;

body_list:
    body
    | body_list body
    ;

body:
    BODY
    {
        ParserBeginBody(parser);
    }
    IDENTIFIER
    {
        ParserSetBodyType(parser, yylval);
    }
    IDENTIFIER
    {
        ParserSetBodyName(parser, yylval);
    }
    body_body
    ;

body_body:
    OPEN_CURLY
    body_inner_body
    CLOSE_CURLY
    {
        ParserEndBody(parser);
    }
    ;

body_inner_body:
    %empty
    | body_attribute_list
    ;

body_attribute_list:
    body_attribute
    | body_attribute_list body_attribute
    ;

body_attribute:
    IDENTIFIER
    {
        ParserBeginAttribute(parser, yylval);
    }
    FAT_ARROW
    value
    SEMICOLON
    {
        ParserEndAttribute(parser);
    }
    ;

value:
    IDENTIFIER
    {
        ParserAddString(parser, yylval);
    }
    | QUOTED_STRING
    {
        ParserAddString(parser, yylval);
    }
    | list
    ;

list:
    OPEN_CURLY
    {
        ParserBeginList(parser);
    }
    inner_list
    CLOSE_CURLY
    {
        ParserEndList(parser);
    }
    ;

inner_list:
    %empty
    | non_empty_list;

non_empty_list:
    value
    | non_empty_list COMMA value
    ;
%%

void print_token(int t, const char *string, Parser *parser)
{
  printf("%d - %-16s - '%s'\n", t, yytname[YYTRANSLATE(t)], string);
}
